<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>myxmlpp: myxmlpp::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">myxmlpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classmyxmlpp_1_1Node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmyxmlpp_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">myxmlpp::Node Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Node_8hpp_source.html">Node.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88767e53f5ae9ffa2b1045768342f0de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a88767e53f5ae9ffa2b1045768342f0de">Node</a> (<a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *parent) noexcept</td></tr>
<tr class="separator:a88767e53f5ae9ffa2b1045768342f0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cac8aeeca899c3111b61a89a2c73e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a19cac8aeeca899c3111b61a89a2c73e6">Node</a> (<a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *parent, std::string tag, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; children) noexcept</td></tr>
<tr class="separator:a19cac8aeeca899c3111b61a89a2c73e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1658a01fc9eb597a4333177eeec440"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a8a1658a01fc9eb597a4333177eeec440">Node</a> (<a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *parent, std::string tag, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt; &gt; attributes, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; children={}) noexcept</td></tr>
<tr class="separator:a8a1658a01fc9eb597a4333177eeec440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb6a8268e2f2c2c5c9fab99eef16e9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a9eb6a8268e2f2c2c5c9fab99eef16e9c">Node</a> (<a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *parent, std::string &amp;str)</td></tr>
<tr class="separator:a9eb6a8268e2f2c2c5c9fab99eef16e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ec4e50c99b3a9f7004709b66b4c0d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aa9ec4e50c99b3a9f7004709b66b4c0d3">asString</a> (bool includeChildren=true) const noexcept</td></tr>
<tr class="separator:aa9ec4e50c99b3a9f7004709b66b4c0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af717258274c9d596acad21e36db3edab"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#af717258274c9d596acad21e36db3edab">asFString</a> (size_t indent, bool includeChildren=true) const noexcept</td></tr>
<tr class="separator:af717258274c9d596acad21e36db3edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90053eb57876395e863532829cc955ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a90053eb57876395e863532829cc955ff">getTag</a> () const noexcept</td></tr>
<tr class="separator:a90053eb57876395e863532829cc955ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b5dbe8e5ba2b5fab3d2c1b72580485"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#af7b5dbe8e5ba2b5fab3d2c1b72580485">getData</a> () const noexcept</td></tr>
<tr class="separator:af7b5dbe8e5ba2b5fab3d2c1b72580485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b1e0c929a2fee8c0dbce5c23931054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a69b1e0c929a2fee8c0dbce5c23931054">getParent</a> () const noexcept</td></tr>
<tr class="separator:a69b1e0c929a2fee8c0dbce5c23931054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef463859ec3f44c0ecab31572b1f69e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aef463859ec3f44c0ecab31572b1f69e1">setTag</a> (const std::string &amp;tag) noexcept</td></tr>
<tr class="separator:aef463859ec3f44c0ecab31572b1f69e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27601972f9f70cb756b710ed969a1c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a27601972f9f70cb756b710ed969a1c53">setData</a> (const std::string &amp;data) noexcept</td></tr>
<tr class="separator:a27601972f9f70cb756b710ed969a1c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4403f1c150ab6b4f51f085a27c7d0de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a4403f1c150ab6b4f51f085a27c7d0de8">setParent</a> (<a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *parent) noexcept</td></tr>
<tr class="separator:a4403f1c150ab6b4f51f085a27c7d0de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0508f9c1e69f2ca5d825fa9fa5617998"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a0508f9c1e69f2ca5d825fa9fa5617998">findAttribute</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a0508f9c1e69f2ca5d825fa9fa5617998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9809fc7a2d03d71bc78f9d85c1731af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a9809fc7a2d03d71bc78f9d85c1731af2">addAttribute</a> (const std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt; &amp;attr) noexcept</td></tr>
<tr class="separator:a9809fc7a2d03d71bc78f9d85c1731af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91702069921a08b4d144e9840657827"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#ae91702069921a08b4d144e9840657827">addAttribute</a> (const std::string &amp;key, const std::string &amp;value) noexcept</td></tr>
<tr class="separator:ae91702069921a08b4d144e9840657827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928a6df1f9bd2f2f9954d2aa73f62d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a928a6df1f9bd2f2f9954d2aa73f62d75">rmAttribute</a> (const std::string &amp;key) noexcept</td></tr>
<tr class="separator:a928a6df1f9bd2f2f9954d2aa73f62d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29da839f0b5a78bf3a29fd115af6386"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#ab29da839f0b5a78bf3a29fd115af6386">popAttribute</a> (const std::string &amp;key) noexcept</td></tr>
<tr class="separator:ab29da839f0b5a78bf3a29fd115af6386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c5e861aef5209c10ce5ff0f6adada2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a28c5e861aef5209c10ce5ff0f6adada2">findChild</a> (const std::string &amp;tag) const</td></tr>
<tr class="separator:a28c5e861aef5209c10ce5ff0f6adada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0f9a0e16b5f313eb9d73567ae585c2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a4b0f9a0e16b5f313eb9d73567ae585c2">findChildR</a> (const std::string &amp;tag, int maxDepth=-1) const</td></tr>
<tr class="separator:a4b0f9a0e16b5f313eb9d73567ae585c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275894898256342a340a2803e387e11e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a275894898256342a340a2803e387e11e">findChildByPath</a> (const std::string &amp;path, const std::string &amp;tag, char delimiter='/') const</td></tr>
<tr class="separator:a275894898256342a340a2803e387e11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c2ba89a08a7d0f15c473c66dd5ceb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a4b4c2ba89a08a7d0f15c473c66dd5ceb">findChildBySPath</a> (const std::string &amp;path, char delimiter='/') const</td></tr>
<tr class="separator:a4b4c2ba89a08a7d0f15c473c66dd5ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3743d883af0c6f5b93af05969940f501"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a3743d883af0c6f5b93af05969940f501">findChildren</a> (const std::string &amp;tag) const</td></tr>
<tr class="separator:a3743d883af0c6f5b93af05969940f501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161399b23bddde0d3676ffc7a3be3193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a161399b23bddde0d3676ffc7a3be3193">findChildren</a> (const std::string &amp;tag, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; *children) const</td></tr>
<tr class="separator:a161399b23bddde0d3676ffc7a3be3193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe583a4e2f91aeb45c334f92d7f2ec99"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#abe583a4e2f91aeb45c334f92d7f2ec99">findChildrenR</a> (const std::string &amp;tag, int maxDepth=-1) const</td></tr>
<tr class="separator:abe583a4e2f91aeb45c334f92d7f2ec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d73eab0db311bff37b2c6429c7f6e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#ab7d73eab0db311bff37b2c6429c7f6e4">findChildrenByPath</a> (const std::string &amp;path, const std::string &amp;tag, char delimiter='/') const</td></tr>
<tr class="separator:ab7d73eab0db311bff37b2c6429c7f6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f24ad6fa4ad92acc8ac0ad51adda9e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a11f24ad6fa4ad92acc8ac0ad51adda9e">findChildrenBySPath</a> (const std::string &amp;path, char delimiter='/') const</td></tr>
<tr class="separator:a11f24ad6fa4ad92acc8ac0ad51adda9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02120cf8f952812f6717e754a2b9b3f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a02120cf8f952812f6717e754a2b9b3f0">addChild</a> (const std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &amp;child) noexcept</td></tr>
<tr class="separator:a02120cf8f952812f6717e754a2b9b3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a6ac491f46cbc8a4997700cd5512e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#ae6a6ac491f46cbc8a4997700cd5512e0">addChildren</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; &amp;children) noexcept</td></tr>
<tr class="separator:ae6a6ac491f46cbc8a4997700cd5512e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c420a1285e3f6a98860ba8a265b94fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a5c420a1285e3f6a98860ba8a265b94fd">addChildByPath</a> (const std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &amp;child, const std::string &amp;path, char delimiter='/')</td></tr>
<tr class="separator:a5c420a1285e3f6a98860ba8a265b94fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38a987144973e9a42c6d1026a928e9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aa38a987144973e9a42c6d1026a928e9e">addChildrenByPath</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; &amp;children, const std::string &amp;path, char delimiter='/')</td></tr>
<tr class="separator:aa38a987144973e9a42c6d1026a928e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17506c8a98c81e92dd3cc1ffdab19519"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a17506c8a98c81e92dd3cc1ffdab19519">rmChild</a> (const std::string &amp;tag) noexcept</td></tr>
<tr class="separator:a17506c8a98c81e92dd3cc1ffdab19519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd13d858eac4a45430d60cc086f376f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#abd13d858eac4a45430d60cc086f376f2">rmChildR</a> (const std::string &amp;tag, int maxDepth=-1) noexcept</td></tr>
<tr class="separator:abd13d858eac4a45430d60cc086f376f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa130a25d681119aca2470230c829f9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aa130a25d681119aca2470230c829f9e2">rmChildByPath</a> (const std::string &amp;path, const std::string &amp;tag, char delimiter='/') noexcept</td></tr>
<tr class="separator:aa130a25d681119aca2470230c829f9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0964856365befbee162c3139e37b914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#af0964856365befbee162c3139e37b914">rmChildBySPath</a> (const std::string &amp;path, char delimiter='/') noexcept</td></tr>
<tr class="separator:af0964856365befbee162c3139e37b914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a944147ffa71ab1f214a70a07e7b49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a2a944147ffa71ab1f214a70a07e7b49d">rmChildren</a> (const std::string &amp;tag) noexcept</td></tr>
<tr class="separator:a2a944147ffa71ab1f214a70a07e7b49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf9eb8e0aaf10cf906d25ce8b0cf29f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a3cf9eb8e0aaf10cf906d25ce8b0cf29f">rmChildrenR</a> (const std::string &amp;tag, int maxDepth=-1) noexcept</td></tr>
<tr class="separator:a3cf9eb8e0aaf10cf906d25ce8b0cf29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80bb7920a43148a182b549e23459e71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aa80bb7920a43148a182b549e23459e71">rmChildrenByPath</a> (const std::string &amp;path, const std::string &amp;tag, char delimiter='/') noexcept</td></tr>
<tr class="separator:aa80bb7920a43148a182b549e23459e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca67a73f5a2b1e1df331ac5d2c6c3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#acca67a73f5a2b1e1df331ac5d2c6c3f5">rmChildrenBySPath</a> (const std::string &amp;path, char delimiter='/') noexcept</td></tr>
<tr class="separator:acca67a73f5a2b1e1df331ac5d2c6c3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc43f972b23f1eef0b365fd452830aa3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#adc43f972b23f1eef0b365fd452830aa3">popChild</a> (const std::string &amp;tag) noexcept</td></tr>
<tr class="separator:adc43f972b23f1eef0b365fd452830aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed350ba2ba70bef007b2c323b18ca065"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aed350ba2ba70bef007b2c323b18ca065">popChildR</a> (const std::string &amp;tag, int maxDepth=-1) noexcept</td></tr>
<tr class="separator:aed350ba2ba70bef007b2c323b18ca065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64296437518fc760d6cf3b44d2fb8e55"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a64296437518fc760d6cf3b44d2fb8e55">popChildByPath</a> (const std::string &amp;path, const std::string &amp;tag, char delimiter='/') noexcept</td></tr>
<tr class="separator:a64296437518fc760d6cf3b44d2fb8e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a4954e8139d3967d7dd058baa8dbed"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a05a4954e8139d3967d7dd058baa8dbed">popChildBySPath</a> (const std::string &amp;path, char delimiter='/') noexcept</td></tr>
<tr class="separator:a05a4954e8139d3967d7dd058baa8dbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aeca5ac78f4dc73e781898ae43e066"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#ae8aeca5ac78f4dc73e781898ae43e066">popChildren</a> (const std::string &amp;tag) noexcept</td></tr>
<tr class="separator:ae8aeca5ac78f4dc73e781898ae43e066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1ea310d3b9bbe7b71f99fb3d8400c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a4e1ea310d3b9bbe7b71f99fb3d8400c7">popChildrenR</a> (const std::string &amp;tag, int maxDepth=-1) noexcept</td></tr>
<tr class="separator:a4e1ea310d3b9bbe7b71f99fb3d8400c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4a2330600c020155541b4d1d973977"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a5c4a2330600c020155541b4d1d973977">popChildrenByPath</a> (const std::string &amp;path, const std::string &amp;tag, char delimiter='/') noexcept</td></tr>
<tr class="separator:a5c4a2330600c020155541b4d1d973977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff3668a11a7307b8ed158dd94e3fa75"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aeff3668a11a7307b8ed158dd94e3fa75">popChildrenBySPath</a> (const std::string &amp;path, char delimiter='/') noexcept</td></tr>
<tr class="separator:aeff3668a11a7307b8ed158dd94e3fa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73e2dee439c6006b7f7be862dceeb3d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#af73e2dee439c6006b7f7be862dceeb3d">getNbChildren</a> () const noexcept</td></tr>
<tr class="separator:af73e2dee439c6006b7f7be862dceeb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcf2927f3067720b0dc1ca4b8620193"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#abfcf2927f3067720b0dc1ca4b8620193">getNbChildrenR</a> () const noexcept</td></tr>
<tr class="separator:abfcf2927f3067720b0dc1ca4b8620193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa77b77138c4337e55ae874be7c55894"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aaa77b77138c4337e55ae874be7c55894">getNbAttributes</a> () const noexcept</td></tr>
<tr class="separator:aaa77b77138c4337e55ae874be7c55894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc39c26eb9cf0371f1e70e16dcba52c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#afbc39c26eb9cf0371f1e70e16dcba52c">getNbAttributesR</a> () const noexcept</td></tr>
<tr class="separator:afbc39c26eb9cf0371f1e70e16dcba52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a6719d8748b1dec09abfec868c16e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aa5a6719d8748b1dec09abfec868c16e5">empty</a> () const noexcept</td></tr>
<tr class="separator:aa5a6719d8748b1dec09abfec868c16e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6455a19a6feaa6fc9d42d63b81fd0c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#af6455a19a6feaa6fc9d42d63b81fd0c0">noAttributes</a> () const noexcept</td></tr>
<tr class="separator:af6455a19a6feaa6fc9d42d63b81fd0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e423ced3d45bc9c991d8912c60234f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a33e423ced3d45bc9c991d8912c60234f">allEmpty</a> () const noexcept</td></tr>
<tr class="separator:a33e423ced3d45bc9c991d8912c60234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a5a5c88094e882c4585045a707a877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a17a5a5c88094e882c4585045a707a877">move</a> (<a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &amp;newParent) noexcept</td></tr>
<tr class="separator:a17a5a5c88094e882c4585045a707a877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abb3f5a507c80b530a1521fd21d9eedf2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#abb3f5a507c80b530a1521fd21d9eedf2">_findChildRecursive</a> (const std::string &amp;tag, int depth) const</td></tr>
<tr class="separator:abb3f5a507c80b530a1521fd21d9eedf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bad6a4d81f8f21c1d7aaec2973ae87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a65bad6a4d81f8f21c1d7aaec2973ae87">_findChildrenRecursive</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; *children, const std::string &amp;tag, int depth) const</td></tr>
<tr class="separator:a65bad6a4d81f8f21c1d7aaec2973ae87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c5b5b64fec854ed0399ce49c4ece05"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a00c5b5b64fec854ed0399ce49c4ece05">_findChildIt</a> (const std::string &amp;tag)</td></tr>
<tr class="separator:a00c5b5b64fec854ed0399ce49c4ece05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c74128853bc353fbb7238faf4a5d48b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a1c74128853bc353fbb7238faf4a5d48b">_popChildRecursive</a> (const std::string &amp;tag, int depth)</td></tr>
<tr class="separator:a1c74128853bc353fbb7238faf4a5d48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80838ff1f7e31ba2b8c3bd6e1aa9dc85"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a80838ff1f7e31ba2b8c3bd6e1aa9dc85">_findChildrenIt</a> (const std::string &amp;tag)</td></tr>
<tr class="separator:a80838ff1f7e31ba2b8c3bd6e1aa9dc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550b741d9e45bd1314d54b1b6a8967d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a550b741d9e45bd1314d54b1b6a8967d5">_popChildrenRecurs</a> (std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; &amp;children, const std::string &amp;tag, int depth)</td></tr>
<tr class="separator:a550b741d9e45bd1314d54b1b6a8967d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972ba35f5d2f3184d93669ed5fba5ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a972ba35f5d2f3184d93669ed5fba5ff9">_extractAttributes</a> (std::string &amp;str) noexcept</td></tr>
<tr class="separator:a972ba35f5d2f3184d93669ed5fba5ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa982c050cc9aff2a59c435bd51b77434"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#aa982c050cc9aff2a59c435bd51b77434">_checkEndOfNode</a> (std::string &amp;str, std::string &amp;remaining) noexcept</td></tr>
<tr class="separator:aa982c050cc9aff2a59c435bd51b77434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d20be91d531273f6d66a5b6cff0cf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a39d20be91d531273f6d66a5b6cff0cf8">Node</a> (<a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *parent, std::string &amp;str, std::string &amp;remaining)</td></tr>
<tr class="separator:a39d20be91d531273f6d66a5b6cff0cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff6f79700d6a516257ce15a60d9150b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#adff6f79700d6a516257ce15a60d9150b">_parseNodeString</a> (std::string &amp;str, std::string &amp;remaining)</td></tr>
<tr class="separator:adff6f79700d6a516257ce15a60d9150b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd903492ce38eb67950ec9c70905e1c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a6fd903492ce38eb67950ec9c70905e1c">_dumpAttrs</a> () const noexcept</td></tr>
<tr class="separator:a6fd903492ce38eb67950ec9c70905e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1104c8b4cc75b4134d696c9829a3b53a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a1104c8b4cc75b4134d696c9829a3b53a">_dumpAttrsF</a> () const noexcept</td></tr>
<tr class="separator:a1104c8b4cc75b4134d696c9829a3b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a2fcf19aa5f13035cb0378e4b24cec7c0"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a2fcf19aa5f13035cb0378e4b24cec7c0">_split</a> (const std::string &amp;str, char delim)</td></tr>
<tr class="separator:a2fcf19aa5f13035cb0378e4b24cec7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43debeb7e4e338cd1f3c9825c1a9022e"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a43debeb7e4e338cd1f3c9825c1a9022e">_searchChild</a> (const <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *current, const std::vector&lt; std::string &gt; &amp;tab, std::vector&lt; std::string &gt;::iterator it)</td></tr>
<tr class="separator:a43debeb7e4e338cd1f3c9825c1a9022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b0f5927465eed1f72d4e880d06fdb5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a24b0f5927465eed1f72d4e880d06fdb5">_isEndOfNode</a> (std::string &amp;str)</td></tr>
<tr class="separator:a24b0f5927465eed1f72d4e880d06fdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39267d8142f3ce4797f01616aa0a3ca2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a39267d8142f3ce4797f01616aa0a3ca2">_performRegex</a> (std::smatch &amp;matches, std::string &amp;regexStr, std::string &amp;str, std::string *remaining=nullptr)</td></tr>
<tr class="separator:a39267d8142f3ce4797f01616aa0a3ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c9501cae3955954bb6c937c5fa301a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a24c9501cae3955954bb6c937c5fa301a">_strIdent</a> (std::size_t indent)</td></tr>
<tr class="separator:a24c9501cae3955954bb6c937c5fa301a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acbbccac2c569c5bde61e089392c24b7b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#acbbccac2c569c5bde61e089392c24b7b">_tag</a></td></tr>
<tr class="separator:acbbccac2c569c5bde61e089392c24b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482ec099eb3493ae207a48340e14fbfb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a482ec099eb3493ae207a48340e14fbfb">_data</a></td></tr>
<tr class="separator:a482ec099eb3493ae207a48340e14fbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf53cd68206573061acfe93611304d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#acf53cd68206573061acfe93611304d70">_parent</a></td></tr>
<tr class="separator:acf53cd68206573061acfe93611304d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d284f6b44dcb96a7af8d65ff99e57a9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a1d284f6b44dcb96a7af8d65ff99e57a9">_attributes</a></td></tr>
<tr class="separator:a1d284f6b44dcb96a7af8d65ff99e57a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b13b628481d71b88f4ac802982abde"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmyxmlpp_1_1Node.html#a84b13b628481d71b88f4ac802982abde">_children</a></td></tr>
<tr class="separator:a84b13b628481d71b88f4ac802982abde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Core class that represent a XML node with tag, attributes, children... </p>

<p class="definition">Definition at line <a class="el" href="Node_8hpp_source.html#l00021">21</a> of file <a class="el" href="Node_8hpp_source.html">Node.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39d20be91d531273f6d66a5b6cff0cf8" name="a39d20be91d531273f6d66a5b6cff0cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d20be91d531273f6d66a5b6cff0cf8">&#9670;&nbsp;</a></span>Node() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">myxmlpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Private constructor to create a node by parsing a xml file in string format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the source string. </td></tr>
    <tr><td class="paramname">remaining</td><td>the remaining characters that could not be parsed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node_8cpp_source.html#l00029">29</a> of file <a class="el" href="Node_8cpp_source.html">Node.cpp</a>.</p>

</div>
</div>
<a id="a88767e53f5ae9ffa2b1045768342f0de" name="a88767e53f5ae9ffa2b1045768342f0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88767e53f5ae9ffa2b1045768342f0de">&#9670;&nbsp;</a></span>Node() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">myxmlpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to create a node with its tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>parent of the node. Can be set to null if the node has not parent </td></tr>
    <tr><td class="paramname">tag</td><td>the tag of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created node. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node_8cpp_source.html#l00013">13</a> of file <a class="el" href="Node_8cpp_source.html">Node.cpp</a>.</p>

</div>
</div>
<a id="a19cac8aeeca899c3111b61a89a2c73e6" name="a19cac8aeeca899c3111b61a89a2c73e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19cac8aeeca899c3111b61a89a2c73e6">&#9670;&nbsp;</a></span>Node() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">myxmlpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to create a node with its tag and its children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>parent of the node. Can be set to null if the node has not parent </td></tr>
    <tr><td class="paramname">tag</td><td>the tag of the node. </td></tr>
    <tr><td class="paramname">children</td><td>a vector with the children nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created node. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node_8cpp_source.html#l00017">17</a> of file <a class="el" href="Node_8cpp_source.html">Node.cpp</a>.</p>

</div>
</div>
<a id="a8a1658a01fc9eb597a4333177eeec440" name="a8a1658a01fc9eb597a4333177eeec440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1658a01fc9eb597a4333177eeec440">&#9670;&nbsp;</a></span>Node() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">myxmlpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>children</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to create a node with its tag, children and attributes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>parent of the node. Can be set to null if the node has not parent </td></tr>
    <tr><td class="paramname">tag</td><td>the tag of the node. </td></tr>
    <tr><td class="paramname">attributes</td><td>a vector of attributes for the node. </td></tr>
    <tr><td class="paramname">children</td><td>a vector of the children nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created node. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node_8cpp_source.html#l00022">22</a> of file <a class="el" href="Node_8cpp_source.html">Node.cpp</a>.</p>

</div>
</div>
<a id="a9eb6a8268e2f2c2c5c9fab99eef16e9c" name="a9eb6a8268e2f2c2c5c9fab99eef16e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb6a8268e2f2c2c5c9fab99eef16e9c">&#9670;&nbsp;</a></span>Node() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">myxmlpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to create a node by parsing a xml file in string format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the source string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1ParsingException.html">ParsingException</a></td><td>if parsing fails. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node_8cpp_source.html#l00037">37</a> of file <a class="el" href="Node_8cpp_source.html">Node.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa982c050cc9aff2a59c435bd51b77434" name="aa982c050cc9aff2a59c435bd51b77434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa982c050cc9aff2a59c435bd51b77434">&#9670;&nbsp;</a></span>_checkEndOfNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::_checkEndOfNode </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Node__parseUtils_8cpp_source.html#l00026">26</a> of file <a class="el" href="Node__parseUtils_8cpp_source.html">Node_parseUtils.cpp</a>.</p>

</div>
</div>
<a id="a6fd903492ce38eb67950ec9c70905e1c" name="a6fd903492ce38eb67950ec9c70905e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd903492ce38eb67950ec9c70905e1c">&#9670;&nbsp;</a></span>_dumpAttrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::_dumpAttrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >@summary This method will return all the attributes serialized in a minimized way (no necessary spaces between attributes) </p><dl class="section return"><dt>Returns</dt><dd>the serialized attributes </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__writeUtils_8cpp_source.html#l00018">18</a> of file <a class="el" href="Node__writeUtils_8cpp_source.html">Node_writeUtils.cpp</a>.</p>

</div>
</div>
<a id="a1104c8b4cc75b4134d696c9829a3b53a" name="a1104c8b4cc75b4134d696c9829a3b53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1104c8b4cc75b4134d696c9829a3b53a">&#9670;&nbsp;</a></span>_dumpAttrsF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::_dumpAttrsF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >@summary This method will return all the attributes serialized with correct spacing formatting </p><dl class="section return"><dt>Returns</dt><dd>the serialized attributes </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__writeUtils_8cpp_source.html#l00033">33</a> of file <a class="el" href="Node__writeUtils_8cpp_source.html">Node_writeUtils.cpp</a>.</p>

</div>
</div>
<a id="a972ba35f5d2f3184d93669ed5fba5ff9" name="a972ba35f5d2f3184d93669ed5fba5ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972ba35f5d2f3184d93669ed5fba5ff9">&#9670;&nbsp;</a></span>_extractAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::_extractAttributes </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Node__parseUtils_8cpp_source.html#l00078">78</a> of file <a class="el" href="Node__parseUtils_8cpp_source.html">Node_parseUtils.cpp</a>.</p>

</div>
</div>
<a id="a00c5b5b64fec854ed0399ce49c4ece05" name="a00c5b5b64fec854ed0399ce49c4ece05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c5b5b64fec854ed0399ce49c4ece05">&#9670;&nbsp;</a></span>_findChildIt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt;::iterator myxmlpp::Node::_findChildIt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChildR_8cpp_source.html#l00012">12</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChildR_8cpp_source.html">Node_popChildR.cpp</a>.</p>

</div>
</div>
<a id="abb3f5a507c80b530a1521fd21d9eedf2" name="abb3f5a507c80b530a1521fd21d9eedf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3f5a507c80b530a1521fd21d9eedf2">&#9670;&nbsp;</a></span>_findChildRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::_findChildRecursive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildR_8cpp_source.html#l00012">12</a> of file <a class="el" href="src_2Node_2find_2Node__findChildR_8cpp_source.html">Node_findChildR.cpp</a>.</p>

</div>
</div>
<a id="a80838ff1f7e31ba2b8c3bd6e1aa9dc85" name="a80838ff1f7e31ba2b8c3bd6e1aa9dc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80838ff1f7e31ba2b8c3bd6e1aa9dc85">&#9670;&nbsp;</a></span>_findChildrenIt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt;::iterator &gt; myxmlpp::Node::_findChildrenIt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChildren_8cpp_source.html#l00012">12</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChildren_8cpp_source.html">Node_popChildren.cpp</a>.</p>

</div>
</div>
<a id="a65bad6a4d81f8f21c1d7aaec2973ae87" name="a65bad6a4d81f8f21c1d7aaec2973ae87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bad6a4d81f8f21c1d7aaec2973ae87">&#9670;&nbsp;</a></span>_findChildrenRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::_findChildrenRecursive </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildrenR_8cpp_source.html#l00011">11</a> of file <a class="el" href="src_2Node_2find_2Node__findChildrenR_8cpp_source.html">Node_findChildrenR.cpp</a>.</p>

</div>
</div>
<a id="a24b0f5927465eed1f72d4e880d06fdb5" name="a24b0f5927465eed1f72d4e880d06fdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b0f5927465eed1f72d4e880d06fdb5">&#9670;&nbsp;</a></span>_isEndOfNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool myxmlpp::Node::_isEndOfNode </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Node__parseUtils_8cpp_source.html#l00012">12</a> of file <a class="el" href="Node__parseUtils_8cpp_source.html">Node_parseUtils.cpp</a>.</p>

</div>
</div>
<a id="adff6f79700d6a516257ce15a60d9150b" name="adff6f79700d6a516257ce15a60d9150b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff6f79700d6a516257ce15a60d9150b">&#9670;&nbsp;</a></span>_parseNodeString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::_parseNodeString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>remaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Node__parseUtils_8cpp_source.html#l00056">56</a> of file <a class="el" href="Node__parseUtils_8cpp_source.html">Node_parseUtils.cpp</a>.</p>

</div>
</div>
<a id="a39267d8142f3ce4797f01616aa0a3ca2" name="a39267d8142f3ce4797f01616aa0a3ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39267d8142f3ce4797f01616aa0a3ca2">&#9670;&nbsp;</a></span>_performRegex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool myxmlpp::Node::_performRegex </td>
          <td>(</td>
          <td class="paramtype">std::smatch &amp;&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>regexStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>remaining</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Node__parseUtils_8cpp_source.html#l00038">38</a> of file <a class="el" href="Node__parseUtils_8cpp_source.html">Node_parseUtils.cpp</a>.</p>

</div>
</div>
<a id="a1c74128853bc353fbb7238faf4a5d48b" name="a1c74128853bc353fbb7238faf4a5d48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c74128853bc353fbb7238faf4a5d48b">&#9670;&nbsp;</a></span>_popChildRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::_popChildRecursive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChildR_8cpp_source.html#l00022">22</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChildR_8cpp_source.html">Node_popChildR.cpp</a>.</p>

</div>
</div>
<a id="a550b741d9e45bd1314d54b1b6a8967d5" name="a550b741d9e45bd1314d54b1b6a8967d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550b741d9e45bd1314d54b1b6a8967d5">&#9670;&nbsp;</a></span>_popChildrenRecurs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::_popChildrenRecurs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChildrenR_8cpp_source.html#l00011">11</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChildrenR_8cpp_source.html">Node_popChildrenR.cpp</a>.</p>

</div>
</div>
<a id="a43debeb7e4e338cd1f3c9825c1a9022e" name="a43debeb7e4e338cd1f3c9825c1a9022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43debeb7e4e338cd1f3c9825c1a9022e">&#9670;&nbsp;</a></span>_searchChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::_searchChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;::iterator&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html#l00026">26</a> of file <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html">Node_findChildByPath.cpp</a>.</p>

</div>
</div>
<a id="a2fcf19aa5f13035cb0378e4b24cec7c0" name="a2fcf19aa5f13035cb0378e4b24cec7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcf19aa5f13035cb0378e4b24cec7c0">&#9670;&nbsp;</a></span>_split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; myxmlpp::Node::_split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html#l00011">11</a> of file <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html">Node_findChildByPath.cpp</a>.</p>

</div>
</div>
<a id="a24c9501cae3955954bb6c937c5fa301a" name="a24c9501cae3955954bb6c937c5fa301a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c9501cae3955954bb6c937c5fa301a">&#9670;&nbsp;</a></span>_strIdent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::_strIdent </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>indent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >@summary This method build a string which contains the necessary indent to format a node in a file during writing </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indent</td><td>the number of tab to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the indentation helper string </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__writeUtils_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__writeUtils_8cpp_source.html">Node_writeUtils.cpp</a>.</p>

</div>
</div>
<a id="a9809fc7a2d03d71bc78f9d85c1731af2" name="a9809fc7a2d03d71bc78f9d85c1731af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9809fc7a2d03d71bc78f9d85c1731af2">&#9670;&nbsp;</a></span>addAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to add an attribute to a node by passing a pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>pointer to the created attribute </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00034">34</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="ae91702069921a08b4d144e9840657827" name="ae91702069921a08b4d144e9840657827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91702069921a08b4d144e9840657827">&#9670;&nbsp;</a></span>addAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">myxmlpp::Attribute</a> &gt; myxmlpp::Node::addAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to add an attribute to a node, this will dynamically allocate an attribute </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the attribute </td></tr>
    <tr><td class="paramname">value</td><td>the value of the attribute </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00024">24</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="a02120cf8f952812f6717e754a2b9b3f0" name="a02120cf8f952812f6717e754a2b9b3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02120cf8f952812f6717e754a2b9b3f0">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::addChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to add a <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> to the children list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> to add </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__addChild_8cpp_source.html#l00012">12</a> of file <a class="el" href="Node__addChild_8cpp_source.html">Node_addChild.cpp</a>.</p>

</div>
</div>
<a id="a5c420a1285e3f6a98860ba8a265b94fd" name="a5c420a1285e3f6a98860ba8a265b94fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c420a1285e3f6a98860ba8a265b94fd">&#9670;&nbsp;</a></span>addChildByPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::addChildByPath </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to add a child to a node referenced by its given path. The path is name tags separated by a slash by default if there no specified separator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>a <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> pointer to the child to add </td></tr>
    <tr><td class="paramname">path</td><td>the path relative to the future parent node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__addChild_8cpp_source.html#l00023">23</a> of file <a class="el" href="Node__addChild_8cpp_source.html">Node_addChild.cpp</a>.</p>

</div>
</div>
<a id="ae6a6ac491f46cbc8a4997700cd5512e0" name="ae6a6ac491f46cbc8a4997700cd5512e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a6ac491f46cbc8a4997700cd5512e0">&#9670;&nbsp;</a></span>addChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::addChildren </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to add children nodes to the children list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">children</td><td>a vector of nodes to add </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__addChild_8cpp_source.html#l00017">17</a> of file <a class="el" href="Node__addChild_8cpp_source.html">Node_addChild.cpp</a>.</p>

</div>
</div>
<a id="aa38a987144973e9a42c6d1026a928e9e" name="aa38a987144973e9a42c6d1026a928e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38a987144973e9a42c6d1026a928e9e">&#9670;&nbsp;</a></span>addChildrenByPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::addChildrenByPath </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to add children to a node referenced by its given path. The path is name tags separated by a slash by default if there no specified separator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">children</td><td>a vector of <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> pointers to the children to add </td></tr>
    <tr><td class="paramname">path</td><td>the path relative to the future parent node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__addChild_8cpp_source.html#l00032">32</a> of file <a class="el" href="Node__addChild_8cpp_source.html">Node_addChild.cpp</a>.</p>

</div>
</div>
<a id="a33e423ced3d45bc9c991d8912c60234f" name="a33e423ced3d45bc9c991d8912c60234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e423ced3d45bc9c991d8912c60234f">&#9670;&nbsp;</a></span>allEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool myxmlpp::Node::allEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Combination of empty and noAttributes method </p><dl class="section return"><dt>Returns</dt><dd>true if there is no child and no attribute </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__getSet_8cpp_source.html#l00037">37</a> of file <a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a>.</p>

</div>
</div>
<a id="af717258274c9d596acad21e36db3edab" name="af717258274c9d596acad21e36db3edab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af717258274c9d596acad21e36db3edab">&#9670;&nbsp;</a></span>asFString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::asFString </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeChildren</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >@summary This method will return the serialized node with indentation formatting</p>
<dl class="section return"><dt>Returns</dt><dd>the serialized node </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__writeUtils_8cpp_source.html#l00065">65</a> of file <a class="el" href="Node__writeUtils_8cpp_source.html">Node_writeUtils.cpp</a>.</p>

</div>
</div>
<a id="aa9ec4e50c99b3a9f7004709b66b4c0d3" name="aa9ec4e50c99b3a9f7004709b66b4c0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ec4e50c99b3a9f7004709b66b4c0d3">&#9670;&nbsp;</a></span>asString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::asString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeChildren</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >@summary This method will return the serialized node minimized </p><dl class="section return"><dt>Returns</dt><dd>the serialized node </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__writeUtils_8cpp_source.html#l00045">45</a> of file <a class="el" href="Node__writeUtils_8cpp_source.html">Node_writeUtils.cpp</a>.</p>

</div>
</div>
<a id="aa5a6719d8748b1dec09abfec868c16e5" name="aa5a6719d8748b1dec09abfec868c16e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a6719d8748b1dec09abfec868c16e5">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool myxmlpp::Node::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check if the node has children </p><dl class="section return"><dt>Returns</dt><dd>true if there is no child </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__children_8cpp_source.html#l00024">24</a> of file <a class="el" href="Node__children_8cpp_source.html">Node_children.cpp</a>.</p>

</div>
</div>
<a id="a0508f9c1e69f2ca5d825fa9fa5617998" name="a0508f9c1e69f2ca5d825fa9fa5617998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0508f9c1e69f2ca5d825fa9fa5617998">&#9670;&nbsp;</a></span>findAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">myxmlpp::Attribute</a> &gt; myxmlpp::Node::findAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find an attribute by its name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the searched attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found attribute </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1AttributeNotFoundException.html">AttributeNotFoundException</a></td><td>if the attribute is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00014">14</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="a28c5e861aef5209c10ce5ff0f6adada2" name="a28c5e861aef5209c10ce5ff0f6adada2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c5e861aef5209c10ce5ff0f6adada2">&#9670;&nbsp;</a></span>findChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::findChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find a child node by its tag. This method will return the first matched node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the child to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChild_8cpp_source.html#l00012">12</a> of file <a class="el" href="src_2Node_2find_2Node__findChild_8cpp_source.html">Node_findChild.cpp</a>.</p>

</div>
</div>
<a id="a275894898256342a340a2803e387e11e" name="a275894898256342a340a2803e387e11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275894898256342a340a2803e387e11e">&#9670;&nbsp;</a></span>findChildByPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::findChildByPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find a child node by a given path. The path is name tags separated by a slash. This method will return the first matched node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">tag</td><td>tag of the node to find </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html#l00038">38</a> of file <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html">Node_findChildByPath.cpp</a>.</p>

</div>
</div>
<a id="a4b4c2ba89a08a7d0f15c473c66dd5ceb" name="a4b4c2ba89a08a7d0f15c473c66dd5ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4c2ba89a08a7d0f15c473c66dd5ceb">&#9670;&nbsp;</a></span>findChildBySPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::findChildBySPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find a child node by a given path. The path is name tags separated by a slash. The last tag name if the tag of the node to find This method will return the first matched node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html#l00049">49</a> of file <a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html">Node_findChildByPath.cpp</a>.</p>

</div>
</div>
<a id="a4b0f9a0e16b5f313eb9d73567ae585c2" name="a4b0f9a0e16b5f313eb9d73567ae585c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0f9a0e16b5f313eb9d73567ae585c2">&#9670;&nbsp;</a></span>findChildR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::findChildR </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find a child node by searching recursively, a max depth can be set. This method will return the first matched node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the node to find </td></tr>
    <tr><td class="paramname">maxDepth</td><td>[optionnal] max depth to search, no limit is -1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildR_8cpp_source.html#l00028">28</a> of file <a class="el" href="src_2Node_2find_2Node__findChildR_8cpp_source.html">Node_findChildR.cpp</a>.</p>

</div>
</div>
<a id="a3743d883af0c6f5b93af05969940f501" name="a3743d883af0c6f5b93af05969940f501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3743d883af0c6f5b93af05969940f501">&#9670;&nbsp;</a></span>findChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::findChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find all children which have the provided tag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the nodes to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tag list of all found nodes </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildren_8cpp_source.html#l00012">12</a> of file <a class="el" href="src_2Node_2find_2Node__findChildren_8cpp_source.html">Node_findChildren.cpp</a>.</p>

</div>
</div>
<a id="a161399b23bddde0d3676ffc7a3be3193" name="a161399b23bddde0d3676ffc7a3be3193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161399b23bddde0d3676ffc7a3be3193">&#9670;&nbsp;</a></span>findChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::findChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">Node</a> &gt; &gt; *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find all children which have the provided tag. The difference is that this method fills a provided vector instead of returning a created one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the nodes to find </td></tr>
    <tr><td class="paramname">node</td><td>list of all found nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7d73eab0db311bff37b2c6429c7f6e4" name="ab7d73eab0db311bff37b2c6429c7f6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d73eab0db311bff37b2c6429c7f6e4">&#9670;&nbsp;</a></span>findChildrenByPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::findChildrenByPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find all children nodes by a given path. The path is name tags separated by a slash by default if there no specified separator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">tag</td><td>tag of the node to find </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildrenByPath_8cpp_source.html#l00011">11</a> of file <a class="el" href="src_2Node_2find_2Node__findChildrenByPath_8cpp_source.html">Node_findChildrenByPath.cpp</a>.</p>

</div>
</div>
<a id="a11f24ad6fa4ad92acc8ac0ad51adda9e" name="a11f24ad6fa4ad92acc8ac0ad51adda9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f24ad6fa4ad92acc8ac0ad51adda9e">&#9670;&nbsp;</a></span>findChildrenBySPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::findChildrenBySPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find all children nodes by a given path. The path is name tags separated by a slash by default if there no specified separator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildrenByPath_8cpp_source.html#l00020">20</a> of file <a class="el" href="src_2Node_2find_2Node__findChildrenByPath_8cpp_source.html">Node_findChildrenByPath.cpp</a>.</p>

</div>
</div>
<a id="abe583a4e2f91aeb45c334f92d7f2ec99" name="abe583a4e2f91aeb45c334f92d7f2ec99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe583a4e2f91aeb45c334f92d7f2ec99">&#9670;&nbsp;</a></span>findChildrenR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::findChildrenR </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method to find all children nodes with the same tag by searching recursively, a max depth can be set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the nodes to find </td></tr>
    <tr><td class="paramname">maxDepth</td><td>[optionnal] max depth to search, no limit is -1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the matched node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmyxmlpp_1_1NodeNotFoundException.html">NodeNotFoundException</a></td><td>when a node is not found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2find_2Node__findChildrenR_8cpp_source.html#l00035">35</a> of file <a class="el" href="src_2Node_2find_2Node__findChildrenR_8cpp_source.html">Node_findChildrenR.cpp</a>.</p>

</div>
</div>
<a id="af7b5dbe8e5ba2b5fab3d2c1b72580485" name="af7b5dbe8e5ba2b5fab3d2c1b72580485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b5dbe8e5ba2b5fab3d2c1b72580485">&#9670;&nbsp;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the data of the xml node </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__getSet_8cpp_source.html#l00015">15</a> of file <a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a>.</p>

</div>
</div>
<a id="aaa77b77138c4337e55ae874be7c55894" name="aaa77b77138c4337e55ae874be7c55894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa77b77138c4337e55ae874be7c55894">&#9670;&nbsp;</a></span>getNbAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int myxmlpp::Node::getNbAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Count the number of attributes of the node, only one level </p><dl class="section return"><dt>Returns</dt><dd>the number of attributes of the node </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00059">59</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="afbc39c26eb9cf0371f1e70e16dcba52c" name="afbc39c26eb9cf0371f1e70e16dcba52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc39c26eb9cf0371f1e70e16dcba52c">&#9670;&nbsp;</a></span>getNbAttributesR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int myxmlpp::Node::getNbAttributesR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Count the number of attributes of the node, at all levels </p><dl class="section return"><dt>Returns</dt><dd>the number of attributes of the node and all sub nodes </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00064">64</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="af73e2dee439c6006b7f7be862dceeb3d" name="af73e2dee439c6006b7f7be862dceeb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73e2dee439c6006b7f7be862dceeb3d">&#9670;&nbsp;</a></span>getNbChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int myxmlpp::Node::getNbChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Count the number of children of the node, only one level </p><dl class="section return"><dt>Returns</dt><dd>the number of children of the node </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__children_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__children_8cpp_source.html">Node_children.cpp</a>.</p>

</div>
</div>
<a id="abfcf2927f3067720b0dc1ca4b8620193" name="abfcf2927f3067720b0dc1ca4b8620193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcf2927f3067720b0dc1ca4b8620193">&#9670;&nbsp;</a></span>getNbChildrenR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int myxmlpp::Node::getNbChildrenR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Count the number of children of the node, at all levels </p><dl class="section return"><dt>Returns</dt><dd>the number of children of the node and all sub nodes </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__children_8cpp_source.html#l00015">15</a> of file <a class="el" href="Node__children_8cpp_source.html">Node_children.cpp</a>.</p>

</div>
</div>
<a id="a69b1e0c929a2fee8c0dbce5c23931054" name="a69b1e0c929a2fee8c0dbce5c23931054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b1e0c929a2fee8c0dbce5c23931054">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> * myxmlpp::Node::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the XML parent node </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__getSet_8cpp_source.html#l00020">20</a> of file <a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a>.</p>

</div>
</div>
<a id="a90053eb57876395e863532829cc955ff" name="a90053eb57876395e863532829cc955ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90053eb57876395e863532829cc955ff">&#9670;&nbsp;</a></span>getTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::getTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the tag of the XML node </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__getSet_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a>.</p>

</div>
</div>
<a id="a17a5a5c88094e882c4585045a707a877" name="a17a5a5c88094e882c4585045a707a877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a5a5c88094e882c4585045a707a877">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Move the current node as a child of the provided node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the future parent node </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__children_8cpp_source.html#l00029">29</a> of file <a class="el" href="Node__children_8cpp_source.html">Node_children.cpp</a>.</p>

</div>
</div>
<a id="af6455a19a6feaa6fc9d42d63b81fd0c0" name="af6455a19a6feaa6fc9d42d63b81fd0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6455a19a6feaa6fc9d42d63b81fd0c0">&#9670;&nbsp;</a></span>noAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool myxmlpp::Node::noAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Check if the node has attributes </p><dl class="section return"><dt>Returns</dt><dd>true if there is no attributes </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00073">73</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="ab29da839f0b5a78bf3a29fd115af6386" name="ab29da839f0b5a78bf3a29fd115af6386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29da839f0b5a78bf3a29fd115af6386">&#9670;&nbsp;</a></span>popAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Attribute.html">myxmlpp::Attribute</a> &gt; myxmlpp::Node::popAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Only remove the object from the attributes list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the attribute to pop </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00045">45</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="adc43f972b23f1eef0b365fd452830aa3" name="adc43f972b23f1eef0b365fd452830aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc43f972b23f1eef0b365fd452830aa3">&#9670;&nbsp;</a></span>popChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::popChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to only remove the object from the children list. This method will pop the first matched node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>tag of the node to pop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the popped node or a null pointer if node is not found </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChild_8cpp_source.html#l00012">12</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChild_8cpp_source.html">Node_popChild.cpp</a>.</p>

</div>
</div>
<a id="a64296437518fc760d6cf3b44d2fb8e55" name="a64296437518fc760d6cf3b44d2fb8e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64296437518fc760d6cf3b44d2fb8e55">&#9670;&nbsp;</a></span>popChildByPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::popChildByPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pop a node from the children list of a child node. The path is name tags separated by a slash. This method will pop the first matched node. This method is equivalent to findChildByPath and then popChild. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">tag</td><td>tag of the node to pop </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the popped node or a null pointer if node is not found </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__popChildByPath_8cpp_source.html#l00011">11</a> of file <a class="el" href="Node__popChildByPath_8cpp_source.html">Node_popChildByPath.cpp</a>.</p>

</div>
</div>
<a id="a05a4954e8139d3967d7dd058baa8dbed" name="a05a4954e8139d3967d7dd058baa8dbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a4954e8139d3967d7dd058baa8dbed">&#9670;&nbsp;</a></span>popChildBySPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::popChildBySPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pop a node from the children list of a child node. The path is name tags separated by a slash. This method will pop the first matched node. This method is equivalent to findChildByPath and then popChild. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the popped node or a null pointer if node is not found </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__popChildByPath_8cpp_source.html#l00023">23</a> of file <a class="el" href="Node__popChildByPath_8cpp_source.html">Node_popChildByPath.cpp</a>.</p>

</div>
</div>
<a id="aed350ba2ba70bef007b2c323b18ca065" name="aed350ba2ba70bef007b2c323b18ca065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed350ba2ba70bef007b2c323b18ca065">&#9670;&nbsp;</a></span>popChildR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; myxmlpp::Node::popChildR </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to pop a node by searching recursively, a max depth can be set. This method will pop the first matched node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the node to remove </td></tr>
    <tr><td class="paramname">maxDepth</td><td>[optionnal] max depth to search, no limit is -1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the popped node or a null pointer if node is not found </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChildR_8cpp_source.html#l00041">41</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChildR_8cpp_source.html">Node_popChildR.cpp</a>.</p>

</div>
</div>
<a id="ae8aeca5ac78f4dc73e781898ae43e066" name="ae8aeca5ac78f4dc73e781898ae43e066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8aeca5ac78f4dc73e781898ae43e066">&#9670;&nbsp;</a></span>popChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::popChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to pop all children which have the provided tag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the nodes to pop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of the popped nodes or an empty list if no node is found </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChildren_8cpp_source.html#l00024">24</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChildren_8cpp_source.html">Node_popChildren.cpp</a>.</p>

</div>
</div>
<a id="a5c4a2330600c020155541b4d1d973977" name="a5c4a2330600c020155541b4d1d973977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4a2330600c020155541b4d1d973977">&#9670;&nbsp;</a></span>popChildrenByPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::popChildrenByPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to find pop children nodes by a given path. The path is name tags separated by a slash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">tag</td><td>tag of the node to pop </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of the popped nodes or an empty list if no node is found </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__popChildrenByPath_8cpp_source.html#l00011">11</a> of file <a class="el" href="Node__popChildrenByPath_8cpp_source.html">Node_popChildrenByPath.cpp</a>.</p>

</div>
</div>
<a id="aeff3668a11a7307b8ed158dd94e3fa75" name="aeff3668a11a7307b8ed158dd94e3fa75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff3668a11a7307b8ed158dd94e3fa75">&#9670;&nbsp;</a></span>popChildrenBySPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::popChildrenBySPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to find pop children nodes by a given path. The path is name tags separated by a slash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of the popped nodes or an empty list if no node is found </dd></dl>

<p class="definition">Definition at line <a class="el" href="Node__popChildrenByPath_8cpp_source.html#l00024">24</a> of file <a class="el" href="Node__popChildrenByPath_8cpp_source.html">Node_popChildrenByPath.cpp</a>.</p>

</div>
</div>
<a id="a4e1ea310d3b9bbe7b71f99fb3d8400c7" name="a4e1ea310d3b9bbe7b71f99fb3d8400c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1ea310d3b9bbe7b71f99fb3d8400c7">&#9670;&nbsp;</a></span>popChildrenR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> &gt; &gt; myxmlpp::Node::popChildrenR </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to pop all children nodes with the same tag by searching recursively, a max depth can be set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the nodes to pop </td></tr>
    <tr><td class="paramname">maxDepth</td><td>[optionnal] max depth to search, no limit is -1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of the popped nodes or an empty list if no node is found </dd></dl>

<p class="definition">Definition at line <a class="el" href="src_2Node_2delete_2pop_2Node__popChildrenR_8cpp_source.html#l00029">29</a> of file <a class="el" href="src_2Node_2delete_2pop_2Node__popChildrenR_8cpp_source.html">Node_popChildrenR.cpp</a>.</p>

</div>
</div>
<a id="a928a6df1f9bd2f2f9954d2aa73f62d75" name="a928a6df1f9bd2f2f9954d2aa73f62d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928a6df1f9bd2f2f9954d2aa73f62d75">&#9670;&nbsp;</a></span>rmAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Remove from the attributes list and delete the attribute object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the attribute to delete </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__attribute_8cpp_source.html#l00039">39</a> of file <a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a>.</p>

</div>
</div>
<a id="a17506c8a98c81e92dd3cc1ffdab19519" name="a17506c8a98c81e92dd3cc1ffdab19519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17506c8a98c81e92dd3cc1ffdab19519">&#9670;&nbsp;</a></span>rmChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Remove from the children list and delete the matching node object. This method will remove the first matched node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the node to remove </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChild_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__rmChild_8cpp_source.html">Node_rmChild.cpp</a>.</p>

</div>
</div>
<a id="aa130a25d681119aca2470230c829f9e2" name="aa130a25d681119aca2470230c829f9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa130a25d681119aca2470230c829f9e2">&#9670;&nbsp;</a></span>rmChildByPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChildByPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Remove a node from the children list of a child node. The path is name tags separated by a slash. This method will remove the first matched node. This method is equivalent to findChildByPath and then rmChild </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">tag</td><td>tag of the node to remove </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChildByPath_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__rmChildByPath_8cpp_source.html">Node_rmChildByPath.cpp</a>.</p>

</div>
</div>
<a id="af0964856365befbee162c3139e37b914" name="af0964856365befbee162c3139e37b914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0964856365befbee162c3139e37b914">&#9670;&nbsp;</a></span>rmChildBySPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChildBySPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Remove a node from the children list of a child node. The path is name tags separated by a slash. This method will remove the first matched node. This method is equivalent to findChildByPath and then rmChild </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChildByPath_8cpp_source.html#l00019">19</a> of file <a class="el" href="Node__rmChildByPath_8cpp_source.html">Node_rmChildByPath.cpp</a>.</p>

</div>
</div>
<a id="abd13d858eac4a45430d60cc086f376f2" name="abd13d858eac4a45430d60cc086f376f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd13d858eac4a45430d60cc086f376f2">&#9670;&nbsp;</a></span>rmChildR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChildR </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to remove a node by searching recursively, a max depth can be set. This method will remove the first matched node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the node to remove </td></tr>
    <tr><td class="paramname">maxDepth</td><td>[optionnal] max depth to search, no limit is -1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChildR_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__rmChildR_8cpp_source.html">Node_rmChildR.cpp</a>.</p>

</div>
</div>
<a id="a2a944147ffa71ab1f214a70a07e7b49d" name="a2a944147ffa71ab1f214a70a07e7b49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a944147ffa71ab1f214a70a07e7b49d">&#9670;&nbsp;</a></span>rmChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChildren </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to remove all children which have the provided tag </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the nodes to remove </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChildren_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__rmChildren_8cpp_source.html">Node_rmChildren.cpp</a>.</p>

</div>
</div>
<a id="aa80bb7920a43148a182b549e23459e71" name="aa80bb7920a43148a182b549e23459e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80bb7920a43148a182b549e23459e71">&#9670;&nbsp;</a></span>rmChildrenByPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChildrenByPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to find remove children nodes by a given path. The path is name tags separated by a slash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">tag</td><td>tag of the node to remove </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChildrenByPath_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__rmChildrenByPath_8cpp_source.html">Node_rmChildrenByPath.cpp</a>.</p>

</div>
</div>
<a id="acca67a73f5a2b1e1df331ac5d2c6c3f5" name="acca67a73f5a2b1e1df331ac5d2c6c3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca67a73f5a2b1e1df331ac5d2c6c3f5">&#9670;&nbsp;</a></span>rmChildrenBySPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChildrenBySPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'/'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to find remove children nodes by a given path. The path is name tags separated by a slash </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path relative to the current node </td></tr>
    <tr><td class="paramname">delimiter</td><td>the separator used in path to delimit nodes </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChildrenByPath_8cpp_source.html#l00018">18</a> of file <a class="el" href="Node__rmChildrenByPath_8cpp_source.html">Node_rmChildrenByPath.cpp</a>.</p>

</div>
</div>
<a id="a3cf9eb8e0aaf10cf906d25ce8b0cf29f" name="a3cf9eb8e0aaf10cf906d25ce8b0cf29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf9eb8e0aaf10cf906d25ce8b0cf29f">&#9670;&nbsp;</a></span>rmChildrenR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::rmChildrenR </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method to remove all children nodes with the same tag by searching recursively, a max depth can be set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag of the nodes to remove </td></tr>
    <tr><td class="paramname">maxDepth</td><td>[optionnal] max depth to search, no limit is -1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__rmChildrenR_8cpp_source.html#l00010">10</a> of file <a class="el" href="Node__rmChildrenR_8cpp_source.html">Node_rmChildrenR.cpp</a>.</p>

</div>
</div>
<a id="a27601972f9f70cb756b710ed969a1c53" name="a27601972f9f70cb756b710ed969a1c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27601972f9f70cb756b710ed969a1c53">&#9670;&nbsp;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::setData </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A method to change the data of the XML node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the new data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__getSet_8cpp_source.html#l00029">29</a> of file <a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a>.</p>

</div>
</div>
<a id="a4403f1c150ab6b4f51f085a27c7d0de8" name="a4403f1c150ab6b4f51f085a27c7d0de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4403f1c150ab6b4f51f085a27c7d0de8">&#9670;&nbsp;</a></span>setParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmyxmlpp_1_1Node.html">myxmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A method to change the parent of the XML node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the new parent </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__getSet_8cpp_source.html#l00033">33</a> of file <a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a>.</p>

</div>
</div>
<a id="aef463859ec3f44c0ecab31572b1f69e1" name="aef463859ec3f44c0ecab31572b1f69e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef463859ec3f44c0ecab31572b1f69e1">&#9670;&nbsp;</a></span>setTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void myxmlpp::Node::setTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A method to change the tag of the XML node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the new tag </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Node__getSet_8cpp_source.html#l00025">25</a> of file <a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1d284f6b44dcb96a7af8d65ff99e57a9" name="a1d284f6b44dcb96a7af8d65ff99e57a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d284f6b44dcb96a7af8d65ff99e57a9">&#9670;&nbsp;</a></span>_attributes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classmyxmlpp_1_1Attribute.html">Attribute</a>&gt; &gt; myxmlpp::Node::_attributes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >List of attributes present in the node </p>

<p class="definition">Definition at line <a class="el" href="Node_8hpp_source.html#l00041">41</a> of file <a class="el" href="Node_8hpp_source.html">Node.hpp</a>.</p>

</div>
</div>
<a id="a84b13b628481d71b88f4ac802982abde" name="a84b13b628481d71b88f4ac802982abde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b13b628481d71b88f4ac802982abde">&#9670;&nbsp;</a></span>_children</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classmyxmlpp_1_1Node.html">Node</a>&gt; &gt; myxmlpp::Node::_children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >List of child nodes </p>

<p class="definition">Definition at line <a class="el" href="Node_8hpp_source.html#l00046">46</a> of file <a class="el" href="Node_8hpp_source.html">Node.hpp</a>.</p>

</div>
</div>
<a id="a482ec099eb3493ae207a48340e14fbfb" name="a482ec099eb3493ae207a48340e14fbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482ec099eb3493ae207a48340e14fbfb">&#9670;&nbsp;</a></span>_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Everything inside the node if it is not a child node </p>

<p class="definition">Definition at line <a class="el" href="Node_8hpp_source.html#l00031">31</a> of file <a class="el" href="Node_8hpp_source.html">Node.hpp</a>.</p>

</div>
</div>
<a id="acf53cd68206573061acfe93611304d70" name="acf53cd68206573061acfe93611304d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf53cd68206573061acfe93611304d70">&#9670;&nbsp;</a></span>_parent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmyxmlpp_1_1Node.html">Node</a>* myxmlpp::Node::_parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A reference to the parent node </p>

<p class="definition">Definition at line <a class="el" href="Node_8hpp_source.html#l00036">36</a> of file <a class="el" href="Node_8hpp_source.html">Node.hpp</a>.</p>

</div>
</div>
<a id="acbbccac2c569c5bde61e089392c24b7b" name="acbbccac2c569c5bde61e089392c24b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbccac2c569c5bde61e089392c24b7b">&#9670;&nbsp;</a></span>_tag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string myxmlpp::Node::_tag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Tag of the XML node </p>

<p class="definition">Definition at line <a class="el" href="Node_8hpp_source.html#l00026">26</a> of file <a class="el" href="Node_8hpp_source.html">Node.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="Node_8hpp_source.html">Node.hpp</a></li>
<li>src/Node/delete/pop/<a class="el" href="src_2Node_2delete_2pop_2Node__popChild_8cpp_source.html">Node_popChild.cpp</a></li>
<li>src/Node/delete/pop/<a class="el" href="Node__popChildByPath_8cpp_source.html">Node_popChildByPath.cpp</a></li>
<li>src/Node/delete/pop/<a class="el" href="src_2Node_2delete_2pop_2Node__popChildR_8cpp_source.html">Node_popChildR.cpp</a></li>
<li>src/Node/delete/pop/<a class="el" href="src_2Node_2delete_2pop_2Node__popChildren_8cpp_source.html">Node_popChildren.cpp</a></li>
<li>src/Node/delete/pop/<a class="el" href="Node__popChildrenByPath_8cpp_source.html">Node_popChildrenByPath.cpp</a></li>
<li>src/Node/delete/pop/<a class="el" href="src_2Node_2delete_2pop_2Node__popChildrenR_8cpp_source.html">Node_popChildrenR.cpp</a></li>
<li>src/Node/delete/rm/<a class="el" href="Node__rmChild_8cpp_source.html">Node_rmChild.cpp</a></li>
<li>src/Node/delete/rm/<a class="el" href="Node__rmChildByPath_8cpp_source.html">Node_rmChildByPath.cpp</a></li>
<li>src/Node/delete/rm/<a class="el" href="Node__rmChildR_8cpp_source.html">Node_rmChildR.cpp</a></li>
<li>src/Node/delete/rm/<a class="el" href="Node__rmChildren_8cpp_source.html">Node_rmChildren.cpp</a></li>
<li>src/Node/delete/rm/<a class="el" href="Node__rmChildrenByPath_8cpp_source.html">Node_rmChildrenByPath.cpp</a></li>
<li>src/Node/delete/rm/<a class="el" href="Node__rmChildrenR_8cpp_source.html">Node_rmChildrenR.cpp</a></li>
<li>src/Node/find/<a class="el" href="src_2Node_2find_2Node__findChild_8cpp_source.html">Node_findChild.cpp</a></li>
<li>src/Node/find/<a class="el" href="src_2Node_2find_2Node__findChildByPath_8cpp_source.html">Node_findChildByPath.cpp</a></li>
<li>src/Node/find/<a class="el" href="src_2Node_2find_2Node__findChildR_8cpp_source.html">Node_findChildR.cpp</a></li>
<li>src/Node/find/<a class="el" href="src_2Node_2find_2Node__findChildren_8cpp_source.html">Node_findChildren.cpp</a></li>
<li>src/Node/find/<a class="el" href="src_2Node_2find_2Node__findChildrenByPath_8cpp_source.html">Node_findChildrenByPath.cpp</a></li>
<li>src/Node/find/<a class="el" href="src_2Node_2find_2Node__findChildrenR_8cpp_source.html">Node_findChildrenR.cpp</a></li>
<li>src/Node/<a class="el" href="Node_8cpp_source.html">Node.cpp</a></li>
<li>src/Node/<a class="el" href="Node__addChild_8cpp_source.html">Node_addChild.cpp</a></li>
<li>src/Node/<a class="el" href="Node__attribute_8cpp_source.html">Node_attribute.cpp</a></li>
<li>src/Node/<a class="el" href="Node__children_8cpp_source.html">Node_children.cpp</a></li>
<li>src/Node/<a class="el" href="Node__getSet_8cpp_source.html">Node_getSet.cpp</a></li>
<li>src/Node/<a class="el" href="Node__parseUtils_8cpp_source.html">Node_parseUtils.cpp</a></li>
<li>src/Node/<a class="el" href="Node__writeUtils_8cpp_source.html">Node_writeUtils.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>myxmlpp</b></li><li class="navelem"><a class="el" href="classmyxmlpp_1_1Node.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
